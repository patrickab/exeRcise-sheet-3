---
title: "Exercise 03"
subtitle: "Fortgeschrittene Statistische Software f√ºr NF - SS 2022/23"
author: "Patrick Bitzer (11551540)"
date: '`r Sys.Date()`'
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, warning = FALSE, message = FALSE)
```


## Exercise 1: Initializing git

### Exercise 1d

strengths

* git is a version control tool, that allows to jump back in the development process and restore old versions of a file, if errors have occured. Version control also allows other people involved in a project to track changes. When developing software this is incredibally useful, as it allows other collaborating project members to examine, what changed since their last login, giving an opportunity easily get an overview over the often chaotic development process. Therefore git also allows developers to be working on the same version of the software, by ensuring that everyone is up-to-date.

* Git is designed to be incredibly efficient and fast. It uses a highly compressed and optimized data storage format, which minimizes the size of the repository on disk and speeds up operations like cloning, committing, branching, and merging. Git's architecture and algorithms are optimized to handle large repositories and scale well with the growth of a project. It is also free and open source, making it an enormous advantage for companies, as they do not need to develop their own software, nor their own server infrastructure

weaknesses

* fully mastering git-fu takes lots of efford to accomplish. Furthmore at first it is usually very difficult for noobs to get into the git basics.

* Git is primarily designed for version control of source code and text-based files. While Git can handle binary files, including large data files, it is not well-suited for managing them efficiently. Large data files can significantly increase the size of the Git repository. Git stores a complete copy of each version of every file in the repository, leading to limited scalability. Git is not designed to store repositories with large files, especially those that frequently change, as git needs to compare and iterate over both the old and the new file, every time that changes in such a big file are commited.


## Exercise 2

### Exercise 2a

https://github.com/patrickab/exeRcise-sheet-3


## Exercise 3

### Exercise 3b

```{r}
library("tidyverse")

vornamen_2021 <- read_csv(file.path("data", "vornamen_2021.csv"))
vornamen_2022 <- read_csv(file.path("data", "vornamen_2022.csv"))

typeof(vornamen_2021$Anzahl)
typeof(vornamen_2022$Anzahl)
```

the values in the "Anzahl" column are stored as character strings instead of numeric values, as the CSV datatype typically stores tabular data (numbers and text) in plain text. Therefore, all column values are by default read in as character strings.

```{r}
vornamen_2021$Anzahl <- as.integer(vornamen_2021$Anzahl)
vornamen_2022$Anzahl <- as.integer(vornamen_2022$Anzahl)

vornamen_2021 %>% head(10)
vornamen_2022 %>% head(10)
```

In both datasets the column "Anzahl" is now stored as integer datatype. Converting these string values to integer values now allows us to perform arithmetic operations on the data.

```{r}
vornamen_2021 %>% tail(10)
vornamen_2022 %>% tail(10)
```

However, since the string value "4 oder weniger" cannot be converted to a integer datatype, therefore each column-value presenting this value has been converted to "NA". In order to not loose data and keep working with at least inaccurate results, these values can be replaced with an integer of value 4. This will result in inaccurate results, as with a probability bordering on certainty not all of those NA's equal 4 in the real world. This leads to inaccuracy of results, and possibly even to incomparability of the datasets, especially if the real world average value of those NA's differs between both datasets and/or if the amount of NA's differs significantly.

```{r}
vornamen_2021$Anzahl <- ifelse(is.na(vornamen_2021$Anzahl), 4, as.integer(vornamen_2021$Anzahl))
vornamen_2022$Anzahl <- ifelse(is.na(vornamen_2022$Anzahl), 4, as.integer(vornamen_2022$Anzahl))

vornamen_2021 %>% tail(10)
vornamen_2022 %>% tail(10)
```


### Exercise 3c

The sum calculated below describes the maximum total number of babies born in 2022 and 2021 according to the dataset provided by the city of Munich.

```{r}
total_2021 <- sum(vornamen_2021$Anzahl, na.rm = TRUE)
total_2022 <- sum(vornamen_2022$Anzahl, na.rm = TRUE)
```

Babies born in Munich, 2021: `r format(total_2021, scientific = FALSE)`

Babies born in Munich, 2022: `r format(total_2022, scientific = FALSE)`

According the dataset, and taking speciied inaccuracies into account, in Munich more babies were born in 2021, than in 2022.

However, in order to determine, which year presented the bigger baby-boom, the increase of birth relative to the previous year needs to be calculated.

```{r}
vornamen_2020 <- read_csv(file.path("data", "vornamen_2020.csv"))
vornamen_2020$Anzahl <- as.integer(vornamen_2020$Anzahl)
vornamen_2020$Anzahl <- ifelse(is.na(vornamen_2020$Anzahl), 4, as.integer(vornamen_2020$Anzahl))
total_2020 <- sum(vornamen_2022$Anzahl, na.rm = TRUE)

increase_2021 <- (total_2021/total_2020 - 1) * 100
increase_2022 <- (total_2022/total_2021 - 1) * 100
```

Increase of births in Munich, 2021 (relative to previous year): `r format(increase_2021, scientific = FALSE)`%

Increase of births in Munich, 2022 (relative to previous year): `r format(increase_2022, scientific = FALSE)`%

In 2021 total births increased, in 2022 total births decreased. Therefore 2021 presented the bigger baby-boom.